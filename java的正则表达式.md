####java的正则表达式
**正则表达式**用于指定字符串的模式，你可以在任何需要定位匹配某种特定模式的字符串的情况下使用正则表达式。

简单实例：正则表达式
`{Jj}ava.+`
匹配下列形式的所有字符串：

* 第一个字母是J或j。
* 接下来的三个字母是ava。
* 字符串的其余部分由一个或多个任意的字符构成。


语法结构：

* **字符类**是一个括在括号中的可选择的字符集，例如，[Jj]、[0-9]、[A-Za-z]、[^0-9]。“-”表示范围（所有Unicode值落在两个边界范围之内的字符），而^表示补集（除了指定字符之外的所有字符）。
* 如果字符类中包含“-”，那么它必须是第一项或最后一项；如果要包含“[”，那么它必须是第一项；如果要包含“^”，那么它可以是除开始位置之外的任何位置。其中，你只需要转义“[”和“\”。
* 有许多预定的字符类。例如\d（数字）和\p{Sc}（Unicode货币符号）。详细请查看《核心技术卷二》表1－8和1-9.
* 大部分字符都可以与它们自身匹配，例如在前面示例中的ava字符。
* 符号可以匹配任何字符（有可能不包括行终止符，这取决于标志的设置）。
* 使用\作为转义字符，例如，\.匹配句号而\\匹配反斜线。
* ^和$分别匹配一行的开头和结尾。
* 如果X和Y是正则表达式，那么XY表示“任何X的匹配后面跟随Y的匹配”，X|Y表示“任何X或Y的匹配”。
* 你可以将量词运用到表达式X:X+（一个或多个）、X*（0个或多个）与X?（0个或1个）。
* 默认情况下，量词要匹配能够使整个匹配成功的最大可能的重复次数。你可以修改这种行为，方法是使用后缀?（使用勉强或吝啬匹配，也就是匹配最小的重复次数）或使用后缀+（使用占有或贪婪匹配，也就是即使让整个匹配失败，也要匹配最大的重复次数）。
  
  例如，字符串cab匹配`[a-z]*ab`,但是不匹配`[a-z]*＋ab`。在第一种情况中，表达式`[a-z]*`只匹配字符c，使得字符ab匹配该模式的剩余部分；但是贪婪版本`[a-z]*＋`将匹配字符cab，模式的剩余部分将无法匹配。
  
* 我们使用群组来定义子表达式，其中群组用括号()括起来。例如，`([+-]?)([0-9]+)`。然后你可以询问模式匹配器，让其返回每个组的匹配，或者用\n来引用某个群组，其中n是群组号（从\1开始）。



