####内部类
**内部类**是定义在另一个类中的类。使用内部类的主要原因：

1. 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。
2. 内部类可以对同一个包中的其他类隐藏起来。
3. 想要定义一个回调函数且不想编写大量代码时，使用**匿名内部类**比较便捷。

在内部类中使用外围类引用的表达式：
*OuterClassName*.this

编译器会将内部类翻译成用$分割外部类名与内部类名的常规类文件，而虚拟机则对其一无所知。例如，在TalkingClock类内部的TimePrinter类将被翻译成类文件TalkingClock$TimePrinter.class。

#####局部内部类
局部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。

局部类有一个优势，即对外部世界可以完全地隐藏起来。此外，它们不仅能够访问包含它们的外部类，还可以访问局部变量。不过那些局部变量必须被声明为final。

#####匿名内部类
将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类。

通常的语法格式为：
`new SuperType(construction parameters)`
`{`
` inner class methods and data`
`}`

其中，SuperType可以是ActionListener这样的接口，于是内部类就要实现这个接口。SuperType也可以是一个类，于是内部类就要扩展它。

由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是，将构造器参数传递给**超类**构造器。尤其是在内部类实现接口的时候，不能有任何构造参数。不仅如此，还要像下面这样提供一组括号：
`new InterfaceType()`
`{`
`methods and data`
`}`
#####静态内部类
有时，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static，以便取消产生的引用。

声明在接口中的内部类自动成为static和public类。
####代理
利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。



